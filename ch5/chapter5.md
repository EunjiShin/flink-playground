# DataStream API (v1.7)

## 헬로우, 플링크

일반적인 플링크 어플리케이션 구조

1. 실행 환경 설정
2. 데이터 소스에서 하나 이상의 스트림 읽기
3. 스트리밍 변환 연산을 적용해 어플리케이션 로직 구현
4. 하나 이상의 싱크로 결과 출력 (선택)
5. 프로그램 실행

### 실행 환경 설정

- `StreamExecutionEnvironment`를 이용한다.
- getExecutionEnvironment() 메서드 호출 문맥에 따라 로컬이나 원격 실행 환경을 반환한다.
  - 원격 클러스터에 연결한 클라이언트라면? -> 원격 실행 환경
  - 그렇지 않다면? -> 로컬 실행 환경
- 로컬이나 원격 실행 환경의 명시적 생성도 가능하다.

### 입력 스트림 읽기

- 메세지 큐, 파일, 또는 즉성에서 데이터를 생성하는 데이터 소스에서 (on the fly) 데이터를 읽을 수 있다.

### 변환 연산 적용

- DataStream 생성 후, 이 객체에 변환 연산을 적용할 수 있다.
  - 다른 종류의 DataStream을 만들거나, 파티션을 나누거나 그룹을 만들어 스트림을 재구성하거나... 
- 여러 변환 연산을 연결하여 어플리케이션 로직을 적용한다.

### 결과 출력

- 스트리밍 어플리케이션은 보통 결과를 카프카나 파일 시스템, DBMS 등으로 내보낸다.
- 플링크는 여러 스트림 싱크를 제공한다.
  - 또는 직접 스트리밍 싱크를 구현할 수 있다.
  - 결과를 내보내지 않고, 내부에 유지하면서, 플링크 쿼리 가능한 상태 기능을 이용해 서비스 할 수 도 있다.

### 실행

- 플링크는 어플리케이션을 지연 실행 한다.
  - 스트림 소스와 변환 연산을 생성하는 API를 호출한다고 바로 데이터 처리가 시작되는 게 아니다.
  - API 호출로 생성한 스트림 소스와 변환 연산을 이용, 실행 계획을 만들고, 변환 연산을 스트림 소스에 차례로 적용한 후, 마지막에 execute()를 호출해 프로그램을 실행한다.

- 플링크는 실행 계획에서 생성한 잡 그래프를 잡매니저로 제출한다.
  - 실행 환경에 따라 잡매니저를 로컬 스레드 혹은 원격으로 전송하여 사용한다.
  - 만약 JM이 원격에서 실행 중이라면, 어플리케이션에 필요한 모든 클래스와 의존성을 포함하는 jar 파일과 잡그래프를 함께 전송한다.

## 변환 연산

플링크 DataStream API의 변환 연산은 크게 네 가지로 분류된다. 

1. 각 이벤트별로 적용하는 기본 변환 연산
2. 키별로 그룹핑한 이벤트에 적용하는 KeyedStream 변환 연산
    - 어떤 속성을 공유하는 이벤트들을 키를 이용해 그룹화하여, 여러 하위 스트림으로 나눈다.
    - 동일 키를 가진 모든 이벤트는 이벤트를 처리할 때 동일 키 상태에 접근할 수 있다.
3. 여러 스트림을 하나의 스트림으로 병합하거나, 하나의 스트림을 여러 스트림으로 분할하는 다중 스트림 변환 연산
4. 스트림 이벤트를 재구성하는 분산 변환 연산
   - 이벤트를 태스크에 어떻게 할당하는지를 정의한다.
   - 연산자 의미와 설정 병렬 값에 따라 자동으로 데이터 교환 전략을 택해, 데이터를 목적지로 보낸다.
   - 때로는 어플리케이션 수준에서 파티셔닝 전략을 제어하거나, 사용자 정의 파티셔너를 정의할 필요가 있다.
     - 스트림 파티션 중 일부에만 데이터가 몰려서 (편향) 연산 부하를 분산시키고 싶거나
     - 어플리케이션의 모든 태스크가 같은 데이터를 받거나
     - 사용자 정의 전략에 따라 이벤트를 분배해야 하거나..

## 병렬 설정

- DataStream을 JM에 제출하면 플링크 시스템은 데이터플로우 그래프를 생성하고, 실행에 필요한 모든 연산자를 준비한다.
- 각 연산자는 하나 이상의 여러 태스크로 병렬화된다.
  - 연산자의 병렬 태스크 수 = 연산자의 병렬 값
  - 연산자의 병렬 값은 실행 환경이나, 개별 연산자 수준에서 제어할 수 있다.
  - 모든 연산자의 기본 병렬 값은 어플리케이션 실행 환경의 병렬 값으로, 실행 환경의 병렬값은 어플리케이션 문맥에 따라 자동으로 초기화된다.
    - 로컬이면 병렬 값은 CPU 코어 개수 만큼
    - 플링크 클러스터라면 병렬 값은 클라이언트가 명시적으로 설정하지 않는 이상 기본 병렬 값으로
  - 보통은 병렬 값을 실행 환경 기본값의 상댓값으로 정의하는게 좋다.
    - 클라이언트를 통해 병렬 값을 조절해 수평 확장을 쉽게 할 수 있다.

## 데이터 타입

- 데이터 객체로 함수를 호출하고, 데이터 객체를 결과로 내보낼 수 있어야 한다.
- 플링크가 데이터 객체를 직렬화하거나 역직렬화하여 네트워크를 통해 전송할 수 있어야 한다.
- 상태 벡엔드, 체크포인트, 세이브포인트에서 데이터 객체를 읽거나 쓸 수 있어야 한다.

> 이를 위해, 플링크는 어플리케이션이 처리하는 데이터의 타입을 타입 정보 라는 개념을 통해 표현한다.

### 지원 데이터 타입

- 플링크는 자바 / 스칼라의 일반적인 데이터 타입을 모두 지원한다.
- 크라이요(Kryo) 직렬화 프레임워크를 사용해 직렬화한다.

### 타입 분류

- 기본 타입 (Primitives)
  - Int (Integer), String, Double과 같은 기본 타입에 대한 타입 정보를 제공한다.
- 자바와 스칼라 튜플 (Tuple)
  - 튜플 : 고정 개수의 타입 필드 여러 개를 갖는 복합 데이터 타입
  - DataStream API는 스칼라 튜플을 사용하며, 자바 튜플 구현 또한 제공한다.
    - 자바 튜플은 25개 필드까지 가질 수 있다.
    - 스칼라 튜플은 Immutable, 자바 튜플은 mutable하다.
    - = 자바 튜플을 사용해 GC 부담을 줄일 수 있다.
- 스칼라 케이스 클래스 (case class)
  - 케이스 클래스 필드는 이름으로 접근할 수 있다.
- POJO
  - 각 데이터 타입을 분석했을 때, 어떤 분류에도 포함되지 않는다면 POJO로 처리 가능한지 검사한다.
  - POJO로 인식하기 위해 만족해야 하는 조건들
    - 공개 클래스
    - 인자가 없는 공개 생성자 = 기본 생성자를 갖고 있다.
    - 모든 필드가 공개이고, getter와 setter로 접근할 수 있다.
      - 게터와 세터는 기본 이름 규칙을 따른다. (getX(), setX())
    - 모든 필드는 플링크가 지원하는 타입으로 되어 있어야 한다.
    - 플링크는 아브로가 생성한 클래스를 POJO로 처리한다.
- Array, List, Map, Enum, 기타 특별한 타입 (e.g., 하둡의 Writable 등)


## TypeInformation 생성

> 플링크 타입 시스템의 핵심 클래스. Serializer와 Comparator를 생성할 때 필요한 정보를 제공한다.

어플리케이션을 실행하려 제출할 때, 플링크 타입 시스템은 프레임워크가 처리할 모든 데이터 타입에 대해 TypeInformation을 자동으로 추론한다.

타입 추출기 객체가 모든 함수의 제너릭 타입과 반환 타입을 분석해 각각의 TypeInformation을 추출한다. 

(타입 추출기는 리플렉션을 이용해 함수의 시그니처와 자식 클래스 정보를 분석한다.)

만약 타입 추출에 실패하거나 사용자 타입을 정의하고 싶다면, 특정 데이터 타입에 대한 TypeInformation을 생성해야 한다. 

TypeInformation을 생성할 때 사용할 수 있는 여러 static 메서드를 자바와 스칼라용 유틸리티 클래스로 제공한다.

### 명시적인 TypeInformation 제공

만약 타입 추출기가 자동 타입 추출에 실패할 경우, 또는 비효율적인 Serializer와 Deserializer를 생성하는 TypeInformation을 선택할 경우 TypeInformation 객체를 명시적으로 제공해야 한다. 

두 가지 방법이 있다.

1. 반환 타입에 대한 TypeInformation을 명시적으로 제공하는 ResultTypeQueryable를 확장해 함수를 구현한다.
2. 자바 DataStream API라면, 데이터 플로우를 정의할 때 연산자 반환 타입을 명시적으로 지정하는 returns() 메서드를 이용할 수 있다.

## 키 정의 방법과 필드 참조

플링크는 키-값 쌍으로 동작하는 시스템처럼, 입력 타입에 대해 미리 키를 정의하지 않는다. 

대신, 입력 데이터를 받아 키를 반환하는 함수를 정의한다.

- 필드 위치
  - 데이터 타입이 튜플일 때, 키 지정을 튜플의 필드 위치로 단순하게 지정할 수 있다.
- 필드 표현식
  - 문자열 기반의 표현식으로 키를 정의하거나 필드를 선택할 수 있다. 
  - 필드 표현식은 튜플, POJO, 케이스 클래스에 대해 사용할 수 있다.
  - 중첩된 필드 선택도 제공한다.
- KeySelector
  - 입력 이벤트를 받아 키를 추출하는 함수. 키를 지정할 때 사용할 수 있다.
  - 키는 입력 이벤트의 필드일 필요 없이, 계산을 통해 지정할 수도 있다.
  - KeySelector은 제네릭 타입이기 때문에, 다른 방식에 비해, 결과를 반환하는 키의 타입 안정성을 강력하게 보장한다는 장점을 갖는다.

## 함수 구현

DataStream API에서 함수를 정의하는 방법은 3가지가 있다. 

1. 함수 클래스 
   - 사용자 정의 함수를 정의할 수 있는 MapFunction, FilterFunction, ProcessFunction과 같은 인터페이스나 추상 클래스를 제공한다.
   - 프로그램을 제출할 때 자바 직렬화를 통해 함수 객체를 직렬화하고, 연산자의 모든 병렬 태스크로 직렬화된 객체를 전송한다.
     - 따라서 모든 설정 값은 객체가 역직렬화되더라도 보존된다.
2. 람다 함수
   - 대부분의 DataStream API 메서드는 람다 함수를 인자로 받는다.
   - 상태나 설정이 필요한 고급 연산자가 아닐 때 단순하고 간결하게 어플리케이션 로직을 구현할 수 있다.
3. RichFunction
   - 첫 번째 레코드를 처리하기 전이나 실행할 때, 함수를 초기화해 필요한 정보를 더 받을 필요가 있을 때, 일반 함수보다 더 많은 기능을 제공하는 RichFunction을 쓸 수 있다.
   - 모든 DataStream API 변환 함수에 대해 RichFunction이 있으며, 일반 함수나 람다 함수를 사용한 동일 위치에서도 쓸 수 있다.
   - 함수 생명 주기과 관련된 메서드 두 개를 추가로 구현할 수 있다.
     - open() : RichFunction 초기화 메서드. 태스크마다 한 번씩 호출됨
     - close() : 함수 마무리 메서드. 마지막 변환 메서드 호출 후, 태스크마다 한 번씩 호출됨
   - 함수의 RuntimeContext 객체에 접근할 수 있다.
     - 함수의 병렬 값이나, 함수 서브태스크 인덱스, 함수 실행 태스크 이름 등의 메타 정보를 추출한다.
     - 파티션 상태에 접근할 수 있는 메서드를 포함한다.